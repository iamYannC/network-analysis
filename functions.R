library(igraph)
library(tidyverse)
library(readxl)
library(glue)

read_matrix <- function(){
  
  #' This function reads the matrixcorrect.xlsx file and returns a list of data frames. It takes no arguments.
  #' 
  #' @returns a list of data frames.
  
  matrixcorrect <- purrr::map(2:5,\(tab) readxl::read_xlsx('input files/matrixcorrect.xlsx', sheet = tab,skip = 1))
  matrixcorrect <- matrixcorrect |> purrr::set_names(c('all','pinks','greens','hetero'))
  
  return(matrixcorrect)
}

read_python <- function(){
  
  #' This function reads the csv files generated by the python code and returns a list of data frames. It takes no arguments.
  #' 
  #' @returns a list of data frames.
  
  py_net <-  readr::read_csv("output files/Network_df.csv")
  py_edge <- readr::read_csv("output files/Edges_df.csv") |> arrange(node1,node2)
  py_node <- readr::read_csv("output files/Nodes_df.csv")
  
  # rename group names -- consider modifying python code
  py_node$node_labels <- case_match(py_node$node_group,
                                   'group1' ~ 'name for cluster 1',
                                   'group2' ~ 'name for cluster 2',
                                   'group3' ~ 'name for cluster 3',
                                   'group4' ~ 'name for cluster 4',
                                   'group5' ~ 'name for cluster 5',
  ) 
  
  return(list(n = py_net, e = py_edge, v = py_node))
}

write_adj <- function(xl,network_name){
  
  #' This function writes an adjacency matrix.
  #' 
  #' @param xl a list of data frames, output of read_matrix.
  #' @param network_name a string, the name of the network.
  #' 
  #' @returns an adjacency matrix.

  adj_matrix <- as.matrix(xl[[network_name]][,-1])
  rownames(adj_matrix) <- colnames(adj_matrix)
  adj_matrix[is.na(adj_matrix)] <- 0
  
  return(adj_matrix)
}

net_init <- function(adj_matrix){
  
  #' This function initializes a network.
  #' 
  #' @param adj_matrix an adjacency matrix, output of write_adj.
  #' 
  #' @returns an igraph object.
  
  inet <- igraph::graph_from_adjacency_matrix(adj_matrix,
                                              mode='undirected', # this ensures that the matrix is symmetric, upper tri only is evaluated
                                              weighted = TRUE,
                                              diag = FALSE,
                                              add.rownames = TRUE)
  
  # Remove nodes with 0 degree
  inet <- inet |> 
    igraph::delete_vertices(which(igraph::degree(inet)==0))
  
  return(inet)
}

filter_py <- function(python_df_list, network_name){
  
  #' This function filters the data frames generated by the python code based on a specific network.
  #' 
  #' @param python_df_list a list of data frames, output of read_python.
  #' @param network_name a string, the name of the network.
  #' 
  #' @returns a list of data frames.
  
  py_net.net <-  python_df_list[['n']]  |> filter(network==network_name)
  py_edge.net <- python_df_list[['e']] |> filter(network==network_name) |> drop_na(edge_weight)
  py_node.net <- python_df_list[['v']] |> filter(network==network_name)
  
  return(list(n = py_net.net, e = py_edge.net, v = py_node.net))

}

custom_layout <- function(network_name,network_obj, layout_function = igraph::layout_with_sugiyama,seed=123){
  
  #' This function creates a custom layout for the network.
  #' The layout is the coordinates of the nodes in the network.
  #' 
  #' @param network_name a string, the name of the network.
  #' @param network_obj an igraph object, output of net_init.
  #' @param layout_function a function, the layout function to use.
  #' @param seed an integer, the seed for the random number generator.
  #' 
  #' @returns a matrix of coordinates.
  #' @note For some layouts, more arguments can be passed. Also, the output might be a list, if so please use `$layout` to access the matrix. Since I designed a custom layout for each network, the seed and layout_function parameters are somewhat useless.
  
  if(network_name == "pinks"){
    
    lay <-  igraph::layout_as_star(network_obj,center = 2,
                                   order = c(1,12,4,
                                             13,7,14,
                                             15,3,8,
                                             6,9,10,
                                             11,2,5
                                   ))
  } else{
    if(network_name == "greens"){
      
      lay <- igraph::layout_with_sugiyama(network_obj)$layout
      lay[,2] <- lay[,2] *.5
      lay[12,] <- c(4,1.5)
      lay[13,] <- c(5,1.5)
      
      # legend postion = c(0.7,.08), horizontal
      
      # lay <- igraph::layout_with_kk(network_obj)
      # l10 <- lay[10,]
      # lay[10,] <- lay[11,] # 213
      # lay[11, ] <- l10 # 310
      # lay[12,] <- lay[12,] + c(2,4) # 311
      # lay[13, ] <- lay[13,] + c(2,4) # 312
      # lay[17,] <- lay[17,2] - 0.2 # 318
      
      
      
      
    } else{
      if(network_name == 'hetero'){
        lay <- igraph::layout_with_sugiyama(network_obj)$layout
        lay[,2] <- lay[,2] *.5
        
        # lgnd_dir = 'vertical', lgnd_pos = c(0.14,0.85))
        
      } else{ # all
        set.seed(seed)  
        lay <- igraph::layout_as_star(network_obj, center = 21,
                                      order = c(1,29,28,27,
                                                30,26,25,24,
                                                3,21,23,22,20,
                                                18,19,2,17,
                                                14,16,13,12,15,
                                                11,10,9,8,
                                                5,7,6,4
                                      )
              # lgnd_dir = 'horizontal', lgnd_pos = c(0.54,1), w = 2, s = 6
        )
      }
    }
  }
  
  return(lay)
}

modify_py <- function(python_df_list_filtered,layout){
  
  #' This function adds the layout coordinates to the data (nodes and edges).
  #' 
  #' @param python_df_list_filtered a list of data frames, output of filter_py.
  #' @param layout a matrix of coordinates, output of custom_layout.
  #' 
  #' @returns a list of data frames.
  
  
  py_node.net <- python_df_list_filtered[['v']] |>mutate(
    x = layout[,1],
    y = layout[,2]
  )
  
  py_edge.net <- python_df_list_filtered[['e']] |> rowwise() |> 
    mutate(
      x = py_node.net$x[py_node.net$node==node1],
      y = py_node.net$y[py_node.net$node==node1],
      xend = py_node.net$x[py_node.net$node==node2],
      yend = py_node.net$y[py_node.net$node==node2],
    ) |> ungroup()
  
  return(list(n = python_df_list_filtered[['n']], e = py_edge.net, v = py_node.net))

}

ggnetwork <- function(python_df_list_modified,network_name,
                      w = 1, s = 5,
                      lgnd_pos  = c(.6,.95), lgnd_dir = 'vertical',
                      label_size_coef = .35, node_size_coef = 1.5,
                      xpnd_x = c(0.2, 0), xpnd_y = c(0.1, 0)
                      ){
  
  #' This function creates a network plot.
  #' 
  #' @param python_df_list_modified a list of data frames, output of modify_py.
  #' @param network_name a string, the name of the network.
  #' @param w a numeric, the edge weight threshold.
  #' @param s a numeric, the node strength threshold.
  #' @param lgnd_pos a numeric vector, the position of the legend.
  #' @param lgnd_dir a string, the direction of the legend. either 'vertical' or 'horizontal'.
  #' @param label_size_coef a numeric, the label size coefficient.
  #' @param node_size_coef a numeric, the node size coefficient.
  #' @param xpnd_x a numeric vector of length 2, the expansion of the x-axis, where the first element is addition and the second is multiplication.
  #' @param xpnd_y a numeric vector of length 2, the expansion of the y-axis, where the first element is addition and the second is multiplication.
  #' 
  #' @returns a ggplot object.
  #' @note The plot can be further customized.
  
  ggplot() +
    geom_curve(data = python_df_list_modified[['e']],
               aes( x = x, xend = xend,
                    y = y, yend = yend,
                    linewidth = edge_weight,
                    alpha = ifelse(edge_weight > w, 0.8, 0.4)
               ),
               curvature = 0, lineend = 'round') +
    
    geom_point(data = python_df_list_modified[['v']],
               aes(x = x,y = y,size = node_strength * node_size_coef,
                   shape = node_labels), fill="grey10") +
    geom_label(data = python_df_list_modified[['v']],
               aes(x = x,y = y, size = node_strength * label_size_coef,
                   label = ifelse(node_strength >= s, node, NA),
               ),
               label.r = unit(0.4, "lines"),
               label.padding = unit(.2, "lines"),
               label.size = unit(0,"lines"),
               fill = 'grey50', alpha = 0.3, color = "white"
    ) +
    
    labs(title = glue::glue(
    "
    Network of {python_df_list_modified[['n']]$net_name}
    "
    ),
         shape="",x="",y=""
    )+
    
    scale_size_identity() +
    scale_linewidth_continuous(range = c(.5,3)) +
    scale_shape_manual(values = c(24,22,21,23,25)) +
    scale_x_continuous(expand = expansion(add=xpnd_x[1],mult=xpnd_x[2]))+
    scale_y_continuous(expand = expansion(add=xpnd_y[1],mult=xpnd_y[2]))+
    
    guides(linewidth="none", size="none", alpha = "none",
           shape = guide_legend(title.position = "top",
                                direction = lgnd_dir,
                                override.aes = list(size = 7)
           )
    ) +
    theme_void(base_size = 15) +
    theme(
      legend.position = lgnd_pos,
      plot.title = element_text(family = 'Calibri'),
      plot.background = element_rect(fill = 'white'),
      panel.background = element_blank(),
      panel.grid = element_blank(), # turn on/off for setting coordinates
      axis.text = element_blank()  # turn on/off for setting coordinates
    )
}
