library(igraph)
library(tidyverse)
library(readxl)
library(glue)

read_matrix <- function(){
  
  #' This function reads the matrixcorrect.xlsx file and returns a list of data frames. It takes no arguments.
  #' 
  #' @returns a list of data frames.
  
  matrixcorrect <- purrr::map(2:5,\(tab) readxl::read_xlsx('input files/matrixcorrect.xlsx', sheet = tab,skip = 1))
  matrixcorrect <- matrixcorrect |> purrr::set_names(c('all','pinks','greens','hetero'))
  
  return(matrixcorrect)
}

read_python <- function(){
  
  #' This function reads the csv files generated by the python code and returns a list of data frames. It takes no arguments.
  #' 
  #' @returns a list of data frames.
  
  py_net <-  readr::read_csv("output files/Network_df.csv")
  py_edge <- readr::read_csv("output files/Edges_df.csv") |> arrange(node1,node2)
  py_node <- readr::read_csv("output files/Nodes_df.csv")
  
  # rename group names -- consider modifying python code
  py_node$node_labels <- case_match(py_node$node_group,
                                   'group1' ~ 'name for cluster 1',
                                   'group2' ~ 'name for cluster 2',
                                   'group3' ~ 'name for cluster 3',
                                   'group4' ~ 'name for cluster 4',
                                   'group5' ~ 'name for cluster 5',
  ) 
  
  return(list(n = py_net, e = py_edge, v = py_node))
}

write_adj <- function(xl,network_name){
  
  #' This function writes an adjacency matrix.
  #' 
  #' @param xl a list of data frames, output of read_matrix.
  #' @param network_name a string, the name of the network.
  #' 
  #' @returns an adjacency matrix.

  adj_matrix <- as.matrix(xl[[network_name]][,-1])
  rownames(adj_matrix) <- colnames(adj_matrix)
  adj_matrix[is.na(adj_matrix)] <- 0
  
  return(adj_matrix)
}

net_init <- function(adj_matrix){
  
  #' This function initializes a network.
  #' 
  #' @param adj_matrix an adjacency matrix, output of write_adj.
  #' 
  #' @returns an igraph object.
  
  inet <- igraph::graph_from_adjacency_matrix(adj_matrix,
                                              mode='undirected', # this ensures that the matrix is symmetric, upper tri only is evaluated
                                              weighted = TRUE,
                                              diag = FALSE,
                                              add.rownames = TRUE)
  
  # Remove nodes with 0 degree
  inet <- inet |> 
    igraph::delete_vertices(which(igraph::degree(inet)==0))
  
  return(inet)
}

filter_py <- function(python_df_list, network_name){
  
  #' This function filters the data frames generated by the python code based on a specific network.
  #' 
  #' @param python_df_list a list of data frames, output of read_python.
  #' @param network_name a string, the name of the network.
  #' 
  #' @returns a list of data frames.
  
  py_net.net <-  python_df_list[['n']]  |> filter(network==network_name)
  py_edge.net <- python_df_list[['e']] |> filter(network==network_name) |> drop_na(edge_weight)
  py_node.net <- python_df_list[['v']] |> filter(network==network_name)
  
  return(list(n = py_net.net, e = py_edge.net, v = py_node.net))

}

custom_layout <- function(network_name,network_obj, layout_function = igraph::layout_with_sugiyama,seed=123){
  
  #' This function creates a custom layout for the network.
  #' The layout is the coordinates of the nodes in the network.
  #' 
  #' @param network_name a string, the name of the network.
  #' @param network_obj an igraph object, output of net_init.
  #' @param layout_function a function, the layout function to use.
  #' @param seed an integer, the seed for the random number generator.
  #' 
  #' @returns a matrix of coordinates.
  #' @note For some layouts, more arguments can be passed. Also, the output might be a list, if so please use `$layout` to access the matrix.
  
  if(network_name == "pinks"){
    
    lay <-  igraph::layout_as_star(network_obj,center = 2,
                           order = c(1,12,4,
                                     13,7,14,
                                     15,3,8,
                                     6,9,10,
                                     11,2,5
                           ))
  } else { # with time, create a specific layout for each network
    
    set.seed(seed)
    lay <- layout_function(network_obj)
  }
  return(lay)
  }

modify_py <- function(python_df_list_filtered,layout){
  
  #' This function adds the layout coordinates to the data (nodes and edges).
  #' 
  #' @param python_df_list_filtered a list of data frames, output of filter_py.
  #' @param layout a matrix of coordinates, output of custom_layout.
  #' 
  #' @returns a list of data frames.
  
  
  py_node.net <- python_df_list_filtered[['v']] |>mutate(
    x = layout[,1],
    y = layout[,2]
  )
  
  py_edge.net <- python_df_list_filtered[['e']] |> rowwise() |> 
    mutate(
      x = py_node.net$x[py_node.net$node==node1],
      y = py_node.net$y[py_node.net$node==node1],
      xend = py_node.net$x[py_node.net$node==node2],
      yend = py_node.net$y[py_node.net$node==node2],
    ) |> ungroup()
  
  return(list(n = python_df_list_filtered[['n']], e = py_edge.net, v = py_node.net))

}

ggnetwork <- function(python_df_list_modified,network_name,
                      w = 1, s = 5,
                      lgnd_pos  = c(.6,.95), lgnd_dir = 'vertical'
                      ){
  
  #' This function creates a network plot.
  #' 
  #' @param python_df_list_modified a list of data frames, output of modify_py.
  #' @param network_name a string, the name of the network.
  #' @param w a numeric, the edge weight threshold.
  #' @param s a numeric, the node strength threshold.
  #' @param lgnd_pos a numeric vector, the position of the legend.
  #' @param lgnd_dir a string, the direction of the legend. either 'vertical' or 'horizontal'.
  #' 
  #' @returns a ggplot object.
  #' @note The plot can be further customized.
  
  ggplot() +
    geom_curve(data = python_df_list_modified[['e']],
               aes( x = x, xend = xend,
                    y = y, yend = yend,
                    linewidth = edge_weight,
                    alpha = ifelse(edge_weight > w, 0.8, 0.4)
               ),
               curvature = 0, lineend = 'round') +
    
    geom_point(data = python_df_list_modified[['v']],
               aes(x = x,y = y,size = node_strength,
                   shape = node_labels), fill="grey10") +
    geom_label(data = python_df_list_modified[['v']],
               aes(x = x,y = y, size = node_strength*.35,
                   label = ifelse(node_strength >= s, node, NA),
               ),
               label.r = unit(0.4, "lines"),
               label.padding = unit(.2, "lines"),
               label.size = unit(0,"lines"),
               fill = 'grey50', alpha = 0.3, color = "white"
    ) +
    
    labs(title = glue::glue(
    "
    Network of {python_df_list_modified[['n']]$net_name}
    "
    ),
         shape="",x="",y=""
    )+
    
    scale_size_identity() +
    scale_linewidth_continuous(range = c(.5,3)) +
    scale_shape_manual(values = c(24,22,21,23,25)) +
    scale_y_continuous(expand = expansion(add=0.2,mult=0))+
    scale_x_continuous(expand = expansion(add=0.1,mult=0))+
    
    guides(linewidth="none", size="none", alpha = "none",
           shape = guide_legend(title.position = "top",
                                direction = lgnd_dir,
                                override.aes = list(size = 7)
           )
    ) +
    theme_void(base_size = 15) +
    theme(
      legend.position = lgnd_pos,
      plot.title = element_text(family = 'Calibri'),
      plot.background = element_blank(),
      panel.background = element_blank(),
      panel.grid = element_blank(), # turn on/off for setting coordinates
      axis.text = element_blank()  # turn on/off for setting coordinates
    )
}